# Використовуючи код з практики зробити додаток "Список справ".

У вас мають бути такі сутності:

TodoTask (name: String, isDone: Bool, dueDate: Date, subtasks: [TodoSubtask] (one-to-many))

TodoSubtask (name: String, isDone: Bool)

Потрібно створити протокол, що слугуватиме інтерфейсом взаємодії з БД. Реалізувати дві імплементації: на базі CoreData (можна використовувати код з практики) та Realm. Передбачити можливість легко перемкнути в коді конкретну імплементацію.

Сервіс роботи з базою має дозволяти CRUD операції.

В додатку має бути список завдань, та передбачено можливості:

- додати нове завдання

- відредагувати завдання (позначити, що виконане, і навпаки)

- видалити (можна за допомогою swipe жесту в списку)

- додати/видалити підзавдання, відредагувати підзавдання (позначити, що виконане, і навпаки) за аналогією

Дизайн та навігація довільні, UI фреймворк довільний.


# Вдосконалюємо наш додаток "Список справ".

1. Додати локальні сповіщення.
Додати до завдання (Task/Subtask) перемикач "увімкнути сповіщення" (на UI зручно використовувати switch). Якщо сповіщення увімкнуто, то під час настання дати due має спрацювати local notification. Якщо сповіщення вимкнути, то надсилання запланованого сповіщення має бути скасовано. Рекомендую виокремити логіку роботи зі сповіщеннями в окремий сервіс.

2. Додати підтримку віддалених сповіщень
Обробляти отримання зовнішніх сповіщень. Зберігати отримані сповіщення і виводити на окремий новий екран "Вхідні", кольором (або як завгодно) позначати, чи отримане сповіщення було прийнято (створено задачу), чи відхилено.

Для обробки сповіщень додати дві дії:

"Прийняти" – при обранні цієї опції додаток має сформувати нове завдання зі сповіщенням увімкненим за замовчуванням, дата due має бути закодована у сповіщенні.
"Видалити" - деструктивна дія - при обранні має просто логувати (print) повідомлення про те, що користувач відмовився від завдання.
При здачі додати окрім проекту файл *.apns.

# Додаємо захист для наших нагадувань.

Завдання 1
(5 балів)
Створити екран з формою вводу email та password (UI довільний).

При запуску додатку авторизовувати користувача на локально розгорнутому сервері (у вкладеннях) за допомогою доступів, збережених в keychain за схемою у вкладеннях. Якщо при запуску в keychain є дані, то ви повинні авторизуватись на сервері не турбуючи користувача. Якщо даних в keychain немає, або вони не дійсні, то потрібно за допомогою новоствореного екрану отримати їх в користувача і у разі успішної авторизації на сервері записати/перезаписати їх.

Завдання 2
(5 балів)
Додати можливість створювати захищені завдання. Текст такого завдання має зберігатись в Keychain. На UI відображати контент (текст) завдання лише після проходження юзером біометричної верифікації.

UI/UX довільний. Як варіант можна у списку показувати замість тексту якусь мітку/кнопку, по натиску на яку буде проведено верифікацію власника пристрою і показано текст завдання у модальному вікні/алерті. Можна також витягувати всі захищені завдання за раз після проходження біометричної авторизації. Можете погратися додатком "Нотатки", створити там пару захищених нотаток і відтворити схожий флоу.

Головне — щоб захищені дані зберігались в keychain, а доступ до них можна було отримати тільки після перевірки, що це власник пристрою. При згортанні/вимкненні додатку потрібно знову приховувати захищені дані.

Можна працювати з keychain безпосередньо, можна використовувати будь-яку бібліотеку. Можливо, найпростіше буде використати KeychainAccess, згадану в лекції.
